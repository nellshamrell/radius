/*
Copyright 2023 The Radius Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package convert

import (
	"context"

	"github.com/radius-project/radius/pkg/cli/clierrors"
	"github.com/radius-project/radius/pkg/cli/filesystem"
	"github.com/radius-project/radius/pkg/cli/framework"
	"github.com/radius-project/radius/pkg/cli/output"
	"github.com/spf13/cobra"
)

const (
	defaultOutputFile = "app.bicep"
)

// NewCommand creates the `rad aspire convert` cobra command and its runner.
func NewCommand(factory framework.Factory) (*cobra.Command, framework.Runner) {
	runner := NewRunner(factory)

	cmd := &cobra.Command{
		Use:   "convert <manifest-file>",
		Short: "Convert an Aspire manifest to a Radius Bicep file",
		Long: `Convert an Aspire manifest JSON file to a Radius-compatible Bicep file.

The command reads an Aspire manifest (generated by 'dotnet run --publisher manifest')
and produces a Radius Bicep file that can be deployed with 'rad deploy'.

Supported Aspire resource types:
  - container.v0, container.v1 → Radius.Compute/containers
  - redis.server.v0            → Applications.Datastores/redisCaches
  - postgres.server.v0         → Radius.Data/postgreSqlDatabases
  - mysql.server.v0            → Radius.Data/mySqlDatabases
  - parameter.v0               → Bicep @secure() parameters

Unsupported resource types are skipped with a warning comment in the output.`,
		Example: `
# Convert an Aspire manifest to app.bicep
rad aspire convert aspire-manifest.json

# Specify a custom output path
rad aspire convert aspire-manifest.json --out-file my-app.bicep

# Overwrite an existing output file
rad aspire convert aspire-manifest.json --force

# Set a custom application name
rad aspire convert aspire-manifest.json --application my-aspire-app`,
		Args: cobra.ExactArgs(1),
		RunE: framework.RunCommand(runner),
	}

	cmd.Flags().StringP("out-file", "", defaultOutputFile, "Output file path for the generated Bicep file.")
	cmd.Flags().BoolP("force", "f", false, "Overwrite the output file if it already exists.")
	cmd.Flags().StringP("application", "a", "", "Name of the Radius application resource. Defaults to a name derived from the manifest.")

	return cmd, runner
}

// Runner is the runner implementation for the `rad aspire convert` command.
type Runner struct {
	Output     output.Interface
	FileSystem filesystem.FileSystem

	// InputFile is the path to the Aspire manifest JSON file.
	InputFile string

	// OutputFile is the path where the generated Bicep file will be written.
	OutputFile string

	// Force indicates whether to overwrite an existing output file.
	Force bool

	// ApplicationName is an optional custom application name.
	ApplicationName string
}

// NewRunner creates a new Runner for the convert command.
func NewRunner(factory framework.Factory) *Runner {
	return &Runner{
		Output: factory.GetOutput(),
	}
}

// Validate checks the command arguments and flags.
func (r *Runner) Validate(cmd *cobra.Command, args []string) error {
	if r.FileSystem == nil {
		r.FileSystem = filesystem.NewOSFS()
	}

	r.InputFile = args[0]

	// Check that the input file exists.
	if !r.FileSystem.Exists(r.InputFile) {
		return clierrors.Message("file not found: %s", r.InputFile)
	}

	var err error
	r.OutputFile, err = cmd.Flags().GetString("out-file")
	if err != nil {
		return err
	}

	r.Force, err = cmd.Flags().GetBool("force")
	if err != nil {
		return err
	}

	r.ApplicationName, err = cmd.Flags().GetString("application")
	if err != nil {
		return err
	}

	// Check for output file conflict (unless --force is set).
	if !r.Force && r.FileSystem.Exists(r.OutputFile) {
		return clierrors.Message("output file already exists: %s (use --force to overwrite)", r.OutputFile)
	}

	return nil
}

// Run executes the conversion pipeline: Parse → Map → Emit → Write.
func (r *Runner) Run(ctx context.Context) error {
	r.Output.LogInfo("Converting Aspire manifest: %s", r.InputFile)

	// Step 1: Read the manifest file.
	data, err := r.FileSystem.ReadFile(r.InputFile)
	if err != nil {
		return clierrors.Message("failed to read manifest file: %s", err)
	}

	// Step 2: Parse the manifest JSON.
	manifest, err := Parse(data)
	if err != nil {
		return clierrors.Message("invalid manifest: %s", err)
	}

	// Step 3: Map Aspire resources to Bicep IR.
	bicepFile := MapManifest(manifest, r.ApplicationName)

	// Step 4: Emit the Bicep text.
	bicepText, err := Emit(bicepFile, r.InputFile)
	if err != nil {
		return clierrors.Message("failed to generate Bicep: %s", err)
	}

	// Step 5: Write the output file.
	err = r.FileSystem.WriteFile(r.OutputFile, []byte(bicepText), 0644)
	if err != nil {
		return clierrors.Message("failed to write output file: %s", err)
	}

	r.Output.LogInfo("Generated: %s", r.OutputFile)

	return nil
}
